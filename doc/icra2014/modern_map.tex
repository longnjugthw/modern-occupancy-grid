\documentclass[letterpaper, 10 pt, conference]{ieeeconf} % letterpaper/a4paper 
% ieeeconf IEEEtran
\IEEEoverridecommandlockouts   % Needed if you want to use the \thanks command
\overrideIEEEmargins

\usepackage[ruled,vlined]{algorithm2e}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{verbatim}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\vect}[1]{\mathbf{#1}}
\newcommand{\hvect}[1]{\bar{\vect{#1}}}
\newcommand{\uvect}[1]{\hat{\vect{#1}}}
\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\Real}[0]{\field{R}}


\title{Modern MAP methods for accurate and faster occupancy grid mapping}
\author{Vikas Dhiman, Brian, Jason J. Corso, Abhijit Kundu, Frank Dallert}
\begin{document}
\maketitle
\begin{abstract}
  Most occupancy grid mapping algorithms have been using two assumption
  algorithm.  \cite{merali2013icra} showed that belief maximization methods
  produce better maps than the traditional two assumption algorithm.  In this
  paper, we show that we can go beyond methods like MCMC Gibbs sampling and
  obtain faster convergence by using modern methods like Sum Product algorithm
  and Dual Decomposition.
\end{abstract}
\section{Problem definition}
A robot equipped with a laser scanner and accurate odometry moves in a static
environment, problem is to figure out an optimal occupancy grid map. For the
purpose of ground robots often 2D maps are enough for path planning and
exploration. 
% define problem in probability terms
The area to be mapped is divided into $N$ discrete cells. Let $x_i$ denote the state of cell $i$, which can take values from label set $L_i = \{0, 1\}$, where $0$ (resp. $1$) denotes that cell is free (resp. occupied). We define, the map $m$ as a vector that defines state for all $N$ cells, $m = [x_i]^\top_{0 \le i < N}$. Hence map $m$ takes values from sample space $\Omega = \prod_{0 \le i < N}L_i$.

Let $z_k$ denote the $k$th laser range measurement when captured from pose $\rho_k$. We assume that the probability of observation $p(z_k| \rho_k, m)$ (forward sensor mdoel) be given. We want to find the marginal probability of a cell $i$ being occupied given $K$ observations $z = [z_k]^\top_{0 \le k < K}$ and $\rho = [\rho_k]^\top_{0 \le k < K}$.
\begin{align}
  &p(x_i = 1 | z, \rho) = \sum_{m \in \Omega : x_i = 1} p(m | z , \rho)
  \label{eq:fullsolution}
\end{align}
Merali et al. \cite{merali2013icra} derive a recursive formula to compute full solution which they observe
to be computationally intractable as its complexity is exponential in the number of cells.

\begin{comment}
  
\section{Full solution}
Next we try to find out the full solution
\begin{align}
  &p(x_i = 1 | z, \rho) = \sum_{m \in \Omega : x_i = 1} p(m | z , \rho)\\
             &= \sum_{m \in \Omega : x_i = 1} \frac{p(m , z , \rho)}{p(z, \rho)} \\
             &= \sum_{m \in \Omega : x_i = 1} \frac{p(z_K, \rho_K|m , z_{1:K-1} , \rho_{1:K-1})p(m, z_{1:K-1}, \rho_{1:K-1})}{p(z, p)}\\
             &= \sum_{m \in \Omega : x_i = 1} \frac{p(z_K, \rho_K|m , z_{1:K-1} , \rho_{1:K-1})p(m| z_{1:K-1}, \rho_{1:K-1})}{p(z_K, \rho_K|z_{1:K-1}, \rho_{1:K-1})}
\end{align}
The current laser range measurement $z_K$ and pose $\rho_K$ can be taken to independent of previous observations $z_{1:K-1}$ and $\rho_{1:K-1}$, which  simplifies above equation to
\begin{align}
  &p(x_i = 1 | z, p)
  = \sum_{m \in \Omega : x_i = 1} \frac{p(z_K, \rho_K|m)p(m| z_{1:K-1}, \rho_{1:K-1})}{p(z_K, \rho_K|z_{1:K-1}, \rho_{1:K-1})}\\
  &= \sum_{m \in \Omega : x_i = 1} \frac{p(z_K|m , \rho_K)p(\rho_K|m)p(m| z_{1:K-1}, \rho_{1:K-1})}{p(z_K|z_{1:K-1}, p)p(\rho_K|z_{1:K-1}, \rho_{1:K-1})}\\
  &= \sum_{m \in \Omega : x_i = 1} \frac{p(z_K|m , \rho_K)p(\rho_K|m)p(m| z_{1:K-1}, \rho_{1:K-1})}{p(z_K|z_{1:K-1}, p)p(\rho_K|z_{1:K-1}, \rho_{1:K-1})}
\end{align}
Another assumption of pose $\rho_K$ being independent of map $m$ yields a simple recursive formula 
\begin{align}
  p(x_i = 1 | z, p)
  = \sum_{m \in \Omega : x_i = 1} \frac{p(z_K|m , \rho_K)p(m| z_{1:K-1}, \rho_{1:K-1})}{p(z_K|z_{1:K-1}, p)}
\end{align}

However, the full solution is computationally intractable as its complexity is exponential in the number of cells.

\end{comment}

\section{Two assumption algorithm}
% assume independence
Eq~\ref{eq:fullsolution} is usually simplified in robotic mapping algorithms by introducing two assumptions:
\begin{align}
\end{align}


\section{Dropping the assumption}
% argue that it is an unreasonable assumption

\section{Representation as factor graph and Notation}
\label{sec:notation}
The problem of Occupancy grid mapping can be expressed as energy minimization
over a factor graph. Let all cells in the map be the variable nodes $V$ and all
the laser measurements be factor nodes $F$. 
There
exists an undirected edge $(i, f)$, if and only if the laser
measurement $f \in F$ passes through the cell $i \in V$. Let $E$ be set of all such edges:
% Mathematically,
\begin{align}
  E = \{(i, f) : i \in V, f \in F, \text{laser $f$ passes through cell $i$}\}
\end{align}
This defines our factor graph representation of occupancy grid mapping $G = (V, F, E)$.

%Let $n(.)$ denote neighborhood in factor graph $G = \{V, F, E\}$.
%
%% unncessary
% i.e
% \begin{align}
%   n(k) &= \begin{cases}
%   \{f \in F: (i, f) \in E\} & \text{ if $k \in V$}\\
%   \{i \in V: (i, f) \in E\} & \text{ if $k \in F$}
%   \end{cases}
% \end{align}
%
Each cell $i \in V$ takes values
from a discrete set of labels $L_i = \{0, 1\}$, where $0$ (respectively $1$) means that
the cell is free (respectively occupied). Also denote the sample space of all the
cells in the map as $\Omega(V) = \prod_{i \in V} L_i$.

Each laser measurement $f \in F$ corresponds to a function $\theta_f : \vect{x}_f \rightarrow \Real$ 
that depends only on the labels of the neighboring cells, $\vect{x}_f = \{x_i\}_{i
\in n(f)}$, and evaluates to an
\emph{energy} value. Here $n(.)$ denotes the neighborhood in the factor graph $G$.
The \emph{energy} can be thought as the negative log likelihood of the given
state $\vect{x}_f$ being the correct state according to the laser measurement $f$.

In this formulation, we seek to determine the label of all the map cells that
maximizes the total likelihood across all measurement, which is equivalent to
minimizing the total \emph{energy} over all factors.
\begin{align}
  \vect{x} = \argmin_{\vect{x} \in \Omega(V)} \sum_{f \in F} \theta_f(\vect{x}_f)
\end{align}
\begin{figure}
  \includegraphics[width=\columnwidth]{../figures/factorgraph/factorgraph.pdf}
  \caption{Diagrammatic conversion of Occupancy Grid to a factor graph.}
  \label{fig:factor-graph}
\end{figure}

\section{Laser sensor model}
\subsection{Gaussian sensor model}
In this sensor model, we assume that the laser measurements are affected by Gaussian noise. The probability of actual distance of first occupied cell $d$ from the robot is a Gaussian with mean as the observed laser distance $\bar{d}$ from the robot.
\begin{align}
  P(d) &= \frac{1}{2\pi\sigma(d)}\exp\left(-\frac{(d - \bar{d})^2}{\sigma(d)^2}\right)
\end{align}
where $\sigma(d)$ is a measure of noise in laser measurement and it often depends on the distance $d$ itself. For our experiments we assume noise to linearly vary with distance as $\sigma(d) = \sigma_0d$. Since $d$ is unknown, we approximate noise computation by using observed laser distance $\bar(d)$ instead of $d$ i.e. $\sigma(d) = \sigma_0\bar{d}$.

In terms of negative log likelihood, the energy function becomes
\begin{align}
  E(d) &= \frac{1}{\sigma_0^2}\left(1 - \frac{d}{\bar{d}}\right)^2
\end{align}
In terms of discrete set of cells that the laser passes through the energy function becomes
\begin{align}
  \theta_f(\vect{x}_f) &= \frac{1}{\sigma_0^2}\left(1 - \frac{\kappa(\vect{x}_f)}{|\vect{x}_f|}\right)^2
\end{align}
where $\kappa(\vect{x}_f)$ denote the index of the first occupied cell in $\vect{x}_f$ and $|\vect{x}_f|$ is the total number of cells observed by the laser. Note that $\theta_f(\vect{x}_f)$ is independent of cell size.

\subsection{Piecewise constant sensor model}
The expected pattern of occupancy from a laser observation is two have last cell as occupied and others as free. So the simplest energy function would be 
\begin{align}
  \theta_f(\vect{x}_f) &= \begin{cases}
              0 & \text{ if } \vect{x}_f = [0, 0 \dots 0, 1]^\top\\
           1000 & \text{ otherwise}
  \end{cases}
\end{align}
where $[0, 0 \dots 0, 1]$ means that all cells are $0$ except the last cell which is $1$. In this context, we consider $\vect{x}^f$ to be a vector of ordered cell labels through which laser measurement $f$ passes.

However, to resolve conflicts it is sometimes better to provide lower energy to all cells free case. Hence, we come with the following energy function.
\begin{align}
  \theta_f(\vect{x}_f) &= \begin{cases}
                     0 & \text{ if } \vect{x}_f = \vect{P}_1\\
                   900 & \text{ if } \vect{x}_f = \vect{P}_2\\
                  1000 & \text{ otherwise}
  \end{cases}
\end{align}
where $\vect{P}_1 = [0, 0 \dots 0, 1]^\top$ and $\vect{P}_2 = [0, 0 \dots 0, 0]^\top$.
\section{Metropolis hastings}
\subsection{Heat map}
\section{Sum product}
\cite{kschischang2001factor} introduced the algorithm.
\subsection{Efficient sum product}
\section{Dual decomposition}
\newcommand{\msg}[3]{\mu_{#1#2}(#3)}
\newcommand{\assign}{\leftarrow}
\newcommand{\Sx}{L_i}
Dual decomposition algorithm employs Lagrangian relaxation technique from integer programming to minimize. Here we explain the implementation of the algorithm without going into mathematical derivations. Interested user is referred to \cite{sontag2011introduction,jojic2010accelerated,komodakis2009beyond} for proofs and more variations of the algorithm. 

Pseudo code for Dual decomposition is provided in Alg~\ref{alg:dualdecompostion}. Apart from input factor graph $G = (V, F, E)$ and label set $\{\Sx\}_{i \in V}$ introduced in Sec~\ref{sec:notation}, Dual decomposition depends on a step size $\alpha$.

The idea for Dual decomposition is to split the minimization problem into \emph{slave} problems that can be efficiently minimized. In case of disagreement for minimizing label among slave problems, the messages to slave problems are updated until the slave problems agree with each other. We maintain the minimizing label for variable node $i$, computed by slave problem corresponding to $f$ as $x^f_i$. Also, we use $\msg{i}{f}{x_i}$ to denote messages from node $i$ to slave problem corresponding to $f$ regarding state $x_i$.

In each iteration of Dual Decomposition, we first minimize all the slave problems getting labels for each pair of variable followed by message update in case of disagreement. Optionally, we can only minimize only those factors that have at least one disagreeing node in their neighborhood.

\begin{algorithm}
  \dontprintsemicolon
  \KwData{\;
  Factor Graph $G = (V, F, E)$\;
  Label set $\{\Sx\}_{i \in V}$\;
  Step size $\alpha > 0$\;
  Maximum number of iterations $N$\;
  }
  \KwResult{Labels $\{x^f_i\}_{(i, f) \in E} $,
  Messages $\{\msg{i}{f}{x_i}\}$}

  $\msg{i}{f}{x_i} \assign 0 \hfill \forall (i, f) \in E, x_i \in \Sx$\;
  $r \assign 1$\;
  \While{$r < N$} {
    \tcp{For disagreeing factors}
    \For {$f \in F$} {% : \exists i, i' \in n(f) : x_i^f \ne x_{i'}^f$} {
      $\vect{x}^f \assign \argmin\limits_{\vect{x}^f} \left( \theta_f(\vect{x}^f) + \sum\limits_{i \in n(f)}\msg{i}{f}{x^f_i} \right)$\;
    }
    \tcp{For disagreeing nodes}
    \For {$i \in V : \exists f, f' \in n(i) : x_i^{f'} \ne x_i^f$} {
      \For{$f \in n(i)$}{
        $\msg{i}{f}{x^f_i} \assign \msg{i}{f}{x^f_i} + \frac{\alpha}{r}$\;
      }
    }
    $r \leftarrow r + 1$\;
  }
  \label{alg:dualdecompostion}
  \caption{Subgradient Dual Decomposition}
\end{algorithm}
We can compute the minimum energy assignment from dual decomposition messages.
\begin{align}
  x_i \assign \argmax\limits_{x_i \in \Sx} \sum\limits_{f \in n(i)} \msg{i}{f}{x_i}
\end{align}
However, the above computation is only valid if the node has at least a pair of disagreeing factors. In case of agreement, we simply take the agreed upon assignment or if the node is not connected to any factors, we take a random assignment.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Unncessary
% \begin{algorithm}
%   \dontprintsemicolon
%   \KwData{\;
%     The Variable Node $i \in V$\;
%     Factor Graph $G = (V, F, E)$\;
%     Label set $\Sx$\;
%     Labels $\{x^f_i\}_{f \in n(i)} $\;
%     Messages $\{\msg{i}{f}{x_i}\}$\;
%   }
%   \KwResult{Minimum energy label $x_i$}
%   \tcc{Check for disagreement}
%   \If{$\exists f, f' \in n(i) : x^{f'}_i \ne x^f_i$}{
%     $x_i \assign \argmax\limits_{x_i \in \Sx} \sum\limits_{f \in n(i)} \msg{i}{f}{x_i}$\;
%   } \Else {
%     \tcc{Take any agreed label}
%     $x_i \assign x^f_i : f \in n(i)$\;
%   }
%   \caption{Label from Dual decomposition messages }
%   \label{alg:compute-assignment}
% \end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Unncessary
\subsection{Efficient slave minimization of piecewise constant factor}
Minimizing slave problem can be done efficiently for specific kinds of functions, for example, piecewise constant functions.
The problem is to minimize the energy function along with the received messages.
\begin{align}
  \min_{\vect{x}^f} \left( \theta(\vect{x}^f) + \sum_{i \in n(f)}\msg{i}{f}{x^f} \right)
\end{align}
A general minimization algorithm will take time of the order that is exponential in the number of cells a laser passes through as $\vect{x}^f$ can have $|L_i|^{|n(f)|}$ possible values. However, for our sensor model we can make use of the fact that the piecewise function needs to look for only two patterns. We should compute the total function value for these two patterns and the minimum value for the \emph{otherwise} case. 
\begin{align}
    \min \theta_f(\vect{x}_f) = \min &\left( 0 + \sum_{\vect{x}_f = \vect{P}_1, i \in n(f)}\msg{i}{f}{x_i},\right.\\
                            &900 + \sum_{\vect{x}_f = \vect{P}_2, i \in n(f)}\msg{i}{f}{x_i},\\
                            &\left.1000 + \min_{\vect{x}_f \not\in \{\vect{P}_1, \vect{P}_2\}} \sum_{i \in n(f)}\msg{i}{f}{x_i} \right)
\end{align}
The third term can be easily minimized by 
%choosing the minimizing state for each $i$ over all possible $\Omega(\vect{x}_f)$ by 
simply choosing the minimizing $x_i \in L_i$ for each $i$. However, the minimizing labels can coincide with patterns $\vect{P}_1$ and $\vect{P}_2$. The solution is to find minimum three assignments of $\sum_{i \in n(f)}\msg{i}{f}{x_i}$ and pick the one that is not equal to $\vect{P}_1$ nor $\vect{P}_2$. 

%
% Algorithm~\ref{alg:efficient-minimize} gives pseudo code for minimizing the last term.
% \begin{algorithm}
%   \SetKwFunction{ArgSortNElements}{ArgSortNElements}
%   $e_i = \min\limits_{x_i \in L_i} \msg{i}{f}{x_i} \hfill, \forall i \in n(f)$\;
%   $x^*_i = \argmin\limits_{x_i \in L_i} \msg{i}{f}{x_i} \hfill, \forall i \in n(f)$\;
%   $\delta_{if}(x_i) = \msg{i}{f}{x_i} - e_i \hfill, \forall i \in n(f), x_i \in L_i, x_i \ne x^*_i$\;
%   $I = \ArgSortNElements(\delta_{if}(x_i), \lceil{\log_{|L_i|}{3}}\rceil)$\;
%   \caption{Efficient minimization of piecewise constant function}
%   \label{alg:efficient-minimize}
% \end{algorithm}

\subsection{Selection of step size}
Step size is critical choice as it affects the speed with which Dual decomposition converges. Fig~\ref{fig:dualdecomposition-stepsize} shows convergence with different step size.
\begin{figure}
  \includegraphics[width=\columnwidth]{../figures/dualdecomposition-stepsize-inc500.pdf}
  \caption{The rate of convergence in dual decomposition depends on step size}
  \label{fig:dualdecomposition-stepsize}
\end{figure}
\section{Belief propagation with disagreement tracking}
Intuitively, dual decomposition converges faster because it focuses on the disagreeing 

\section{Experiments} 
Sampling algorithms are liable to getting stuck in a local minima because we flip only one cell at a time.

Dual decomposition converges better because it only focuses on disagreements.
% Data source
I have used \emph{Player 3.0.2} and \emph{Stage 3.2.2} \cite{gerkey2003player} for simulating input data.

\bibliographystyle{IEEEtran}
\newcommand{\bibdatabase}{/home/vikasdhi/wrk/biblib/bibdb}
\IfFileExists{\bibdatabase.bib}{
  \bibliography{\bibdatabase}
}{
  \bibliography{modern_map}
}
  
\end{document}

